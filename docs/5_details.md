Техническое проектирование My_FileDB - Этап 5: Детали реализации
5.1 Архитектура проекта Java
Пакетная структура и ответственность

core/ - Бизнес-логика ядра БД:

    DatabaseEngine - оркестрация всех операций с данными

    DatabaseSession - управление состоянием активной сессии

    DatabaseInitializer - инициализация и валидация БД

storage/ - Файловая система хранения:

    FileManager - абстракция над файловыми операциями с буферизацией

    DataFileHandler - работа с записями сотрудников в data.db

    IndexManager - хэш-таблица для быстрого поиска по ID

    MetaFileHandler - управление метаданными БД в meta.db

    RecordFormat - константы и утилиты сериализации

model/ - Модели предметной области:

    Employee - сущность сотрудника с валидацией бизнес-правил

    DatabaseMeta - метаинформация о состоянии БД

    IndexSlot - элемент хэш-таблицы индекса

api/ - Слой веб-интерфейса:

    HttpServer - встроенный веб-сервер (Javalin/Spark)

    EmployeeController - REST API для операций с сотрудниками

    DatabaseController - API управления БД

    DTO классы для сериализации JSON

util/ - Вспомогательные утилиты:

    SerializationUtil - преобразование объектов↔байты с фиксированной длиной

    ValidationUtil - клиентская и серверная валидация данных

    IOUtil - оптимизированные операции ввода-вывода

exceptions/ - Иерархия обработки ошибок:

    DatabaseException - базовое исключение с кодом ошибки

    ValidationException - ошибки валидации входных данных

    FileAccessException - проблемы доступа к файлам

5.2 Стратегия обработки ошибок
Классификация исключений
Файловые ошибки:

FILE_NOT_FOUND - отсутствуют файлы БД

PERMISSION_DENIED - недостаточно прав для операций

DISK_FULL - недостаточно места на диске

CORRUPTED_DATA - нарушение целостности данных

Бизнес-логика:

DUPLICATE_KEY - нарушение уникальности ID

EMPLOYEE_NOT_FOUND - запись не существует

VALIDATION_ERROR - несоответствие формату данных

Системные ошибки:

DATABASE_NOT_LOADED - операции без активной сессии

CONCURRENT_ACCESS - конфликт параллельных операций

Механизмы обеспечения надежности
Транзакционность операций:

java
// Паттерн "Write-Ahead Log" для критичных операций
public void updateEmployee(Employee employee) {
    try {
        beginTransaction();
        // 1. Запись в временный файл
        writeToTempFile(employee);
        // 2. Валидация данных
        validateUpdate(employee); 
        // 3. Атомарная замена файлов
        commitTransaction();
    } catch (Exception e) {
        rollbackTransaction();
        throw e;
    }
}
Конкурентный доступ:

ReadWriteLock для разделения операций чтения/записи

synchronized блоки для критических секций

Оптимистичные блокировки для высоконагруженных сценариев

Восстановление после сбоев:

Проверка контрольных сумм при загрузке БД

Автоматическое восстановление из backup при повреждениях

Детальное логирование всех операций для диагностики

5.3 Оптимизация производительности
Стратегия работы с диском
Буферизация операций:

Чтение: 8KB буфер для последовательного доступа

Запись: 16KB буфер с отложенной записью (write-back)

Индекс: In-memory копия хэш-таблицы с периодической синхронизацией

Критерии сброса буферов:

Принудительный сброс при вызове flush()

Автоматический сброс при заполнении буфера

Сброс при завершении транзакций

Периодический сброс по таймеру (30 секунд)

Производительность операций
Оптимизированные операции:

Поиск по ID: O(1) через in-memory индекс + одно чтение с диска

Добавление записи: O(1) - запись в конец файла + обновление индекса

Удаление по ID: O(1) - логическое удаление + обновление индекса

Поиск по неключевым полям: O(n) - полное сканирование с буферизацией

Параметры настройки производительности:

java
public class PerformanceConfig {
    public static final int BUFFER_SIZE = 8192;          // 8KB
    public static final int INDEX_BATCH_SIZE = 100;      // Пакетная обработка
    public static final int CACHE_SIZE = 1000;           // LRU кэш записей
    public static final long AUTO_FLUSH_INTERVAL = 30000; // 30 секунд
}
Управление памятью
Кэширование часто используемых данных:

LRU кэш последних записей для уменьшения обращений к диску

In-memory копия индекса для мгновенного поиска

Пулы буферов для минимизации аллокаций памяти

Профилирование использования ресурсов:

Мониторинг размера файлов БД

Трассировка времени выполнения операций

Статистика попаданий в кэш

Ключевые технические решения
1. Формат сериализации
Фиксированная длина записей (256 байт) для простоты реализации

Бинарный формат для эффективного использования пространства

Прямой доступ по смещению без парсинга

2. Управление индексами
In-memory хэш-таблица для максимальной производительности

Периодическая синхронизация с диском для надежности

Автоматическое рехэширование при достижении load factor

3. Стратегия ввода-вывода
Буферизованные операции для минимизации системных вызовов

Асинхронная запись для отзывчивости UI

Атомарные операции через временные файлы

4. Обработка ошибок
Декларативная валидация на всех уровнях приложения

Гранулярные исключения с кодами ошибок

Единый формат ответов для клиента

Данная архитектура обеспечивает баланс между производительностью, надежностью и простотой реализации, полностью соответствуя требованиям лабораторной работы.